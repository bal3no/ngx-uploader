{"hash":"c7b29af645e282f7fbf8a911da9d8dd4bde557e9","fesm2022":[{"exports":["NgFileDropDirective","NgFileSelectDirective","NgUploaderService","NgxUploaderModule","UploadStatus","humanizeBytes"],"facadeModuleId":"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/ngx-uploader.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/interfaces.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ngx-uploader.class.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ng-file-drop.directive.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ng-file-select.directive.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ngx-uploader.module.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/public_api.mjs","/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/ngx-uploader.mjs"],"name":"ngx-uploader","type":"chunk","dynamicImports":[],"fileName":"ngx-uploader.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["EventEmitter","*","Directive","Input","Output","HostListener","NgModule"],"rxjs":["Subject","Observable"],"rxjs/operators":["mergeMap","finalize"]},"imports":["@angular/core","rxjs","rxjs/operators"],"modules":{"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/interfaces.mjs":{"code":"var UploadStatus;\n(function (UploadStatus) {\n    UploadStatus[UploadStatus[\"Queue\"] = 0] = \"Queue\";\n    UploadStatus[UploadStatus[\"Uploading\"] = 1] = \"Uploading\";\n    UploadStatus[UploadStatus[\"Done\"] = 2] = \"Done\";\n    UploadStatus[UploadStatus[\"Cancelled\"] = 3] = \"Cancelled\";\n})(UploadStatus || (UploadStatus = {}));","originalLength":3025,"removedExports":[],"renderedExports":["UploadStatus"],"renderedLength":319},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ngx-uploader.class.mjs":{"code":"function humanizeBytes(bytes) {\n    if (bytes === 0) {\n        return '0 Byte';\n    }\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nclass NgUploaderService {\n    queue;\n    serviceEvents;\n    uploadScheduler;\n    subs;\n    contentTypes;\n    maxUploads;\n    maxFileSize;\n    constructor(concurrency = Number.POSITIVE_INFINITY, contentTypes = ['*'], maxUploads = Number.POSITIVE_INFINITY, maxFileSize = Number.POSITIVE_INFINITY) {\n        this.queue = [];\n        this.serviceEvents = new EventEmitter();\n        this.uploadScheduler = new Subject();\n        this.subs = [];\n        this.contentTypes = contentTypes;\n        this.maxUploads = maxUploads;\n        this.maxFileSize = maxFileSize;\n        this.uploadScheduler\n            .pipe(mergeMap(upload => this.startUpload(upload), concurrency))\n            .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n    }\n    handleFiles(incomingFiles) {\n        const allowedIncomingFiles = [].reduce.call(incomingFiles, (acc, checkFile, i) => {\n            const futureQueueLength = acc.length + this.queue.length + 1;\n            if (this.isContentTypeAllowed(checkFile.type) &&\n                futureQueueLength <= this.maxUploads &&\n                this.isFileSizeAllowed(checkFile.size)) {\n                acc = acc.concat(checkFile);\n            }\n            else {\n                const rejectedFile = this.makeUploadFile(checkFile, i);\n                this.serviceEvents.emit({ type: 'rejected', file: rejectedFile });\n            }\n            return acc;\n        }, []);\n        this.queue.push(...[].map.call(allowedIncomingFiles, (file, i) => {\n            const uploadFile = this.makeUploadFile(file, i);\n            this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });\n            return uploadFile;\n        }));\n        this.serviceEvents.emit({ type: 'allAddedToQueue' });\n    }\n    initInputEvents(input) {\n        return input.subscribe((event) => {\n            switch (event.type) {\n                case 'uploadFile':\n                    const uploadFileIndex = this.queue.findIndex(file => file === event.file);\n                    if (uploadFileIndex !== -1 && event.file) {\n                        this.uploadScheduler.next({ file: this.queue[uploadFileIndex], event: event });\n                    }\n                    break;\n                case 'uploadAll':\n                    const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n                    files.forEach(file => this.uploadScheduler.next({ file: file, event: event }));\n                    break;\n                case 'cancel':\n                    const id = event.id || null;\n                    if (!id) {\n                        return;\n                    }\n                    const subs = this.subs.filter(sub => sub.id === id);\n                    subs.forEach(sub => {\n                        if (sub.sub) {\n                            sub.sub.unsubscribe();\n                            const fileIndex = this.queue.findIndex(file => file.id === id);\n                            if (fileIndex !== -1) {\n                                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n                                this.serviceEvents.emit({ type: 'cancelled', file: this.queue[fileIndex] });\n                            }\n                        }\n                    });\n                    break;\n                case 'cancelAll':\n                    this.subs.forEach(sub => {\n                        if (sub.sub) {\n                            sub.sub.unsubscribe();\n                        }\n                        const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n                        if (file) {\n                            file.progress.status = UploadStatus.Cancelled;\n                            this.serviceEvents.emit({ type: 'cancelled', file: file });\n                        }\n                    });\n                    break;\n                case 'remove':\n                    if (!event.id) {\n                        return;\n                    }\n                    const i = this.queue.findIndex(file => file.id === event.id);\n                    if (i !== -1) {\n                        const file = this.queue[i];\n                        this.queue.splice(i, 1);\n                        this.serviceEvents.emit({ type: 'removed', file: file });\n                    }\n                    break;\n                case 'removeAll':\n                    if (this.queue.length) {\n                        this.queue = [];\n                        this.serviceEvents.emit({ type: 'removedAll' });\n                    }\n                    break;\n            }\n        });\n    }\n    startUpload(upload) {\n        return new Observable(observer => {\n            const sub = this.uploadFile(upload.file, upload.event)\n                .pipe(finalize(() => {\n                if (!observer.closed) {\n                    observer.complete();\n                }\n            }))\n                .subscribe(output => {\n                observer.next(output);\n            }, err => {\n                observer.error(err);\n                observer.complete();\n            }, () => {\n                observer.complete();\n            });\n            this.subs.push({ id: upload.file.id, sub: sub });\n        });\n    }\n    uploadFile(file, event) {\n        return new Observable(observer => {\n            const url = event.url || '';\n            const method = event.method || 'POST';\n            const data = event.data || {};\n            const headers = event.headers || {};\n            const xhr = new XMLHttpRequest();\n            const time = new Date().getTime();\n            let progressStartTime = (file.progress.data && file.progress.data.startTime) || time;\n            let speed = 0;\n            let eta = null;\n            xhr.upload.addEventListener('progress', (e) => {\n                if (e.lengthComputable) {\n                    const percentage = Math.round((e.loaded * 100) / e.total);\n                    const diff = new Date().getTime() - time;\n                    speed = Math.round((e.loaded / diff) * 1000);\n                    progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\n                    eta = Math.ceil((e.total - e.loaded) / speed);\n                    file.progress = {\n                        status: UploadStatus.Uploading,\n                        data: {\n                            percentage: percentage,\n                            speed: speed,\n                            speedHuman: `${humanizeBytes(speed)}/s`,\n                            startTime: progressStartTime,\n                            endTime: null,\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta)\n                        }\n                    };\n                    observer.next({ type: 'uploading', file: file });\n                }\n            }, false);\n            xhr.upload.addEventListener('error', (e) => {\n                observer.error(e);\n                observer.complete();\n            });\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === XMLHttpRequest.DONE) {\n                    const speedAverage = Math.round((file.size / (new Date().getTime() - progressStartTime)) * 1000);\n                    file.progress = {\n                        status: UploadStatus.Done,\n                        data: {\n                            percentage: 100,\n                            speed: speedAverage,\n                            speedHuman: `${humanizeBytes(speedAverage)}/s`,\n                            startTime: progressStartTime,\n                            endTime: new Date().getTime(),\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta || 0)\n                        }\n                    };\n                    file.responseStatus = xhr.status;\n                    try {\n                        file.response = JSON.parse(xhr.response);\n                    }\n                    catch (e) {\n                        file.response = xhr.response;\n                    }\n                    file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n                    observer.next({ type: 'done', file: file });\n                    observer.complete();\n                }\n            };\n            xhr.open(method, url, true);\n            xhr.withCredentials = event.withCredentials;\n            try {\n                const uploadFile = file.nativeFile;\n                const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n                if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n                    observer.complete();\n                }\n                Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n                let bodyToSend;\n                if (event.includeWebKitFormBoundary !== false) {\n                    Object.keys(data).forEach(key => file.form.append(key, data[key]));\n                    file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n                    bodyToSend = file.form;\n                }\n                else {\n                    bodyToSend = uploadFile;\n                }\n                this.serviceEvents.emit({ type: 'start', file: file });\n                xhr.send(bodyToSend);\n            }\n            catch (e) {\n                observer.complete();\n            }\n            return () => {\n                xhr.abort();\n            };\n        });\n    }\n    secondsToHuman(sec) {\n        return new Date(sec * 1000).toISOString().substr(11, 8);\n    }\n    generateId() {\n        return Math.random().toString(36).substring(7);\n    }\n    setContentTypes(contentTypes) {\n        if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\n            if (contentTypes.find((type) => type === '*') !== undefined) {\n                this.contentTypes = ['*'];\n            }\n            else {\n                this.contentTypes = contentTypes;\n            }\n            return;\n        }\n        this.contentTypes = ['*'];\n    }\n    allContentTypesAllowed() {\n        return this.contentTypes.find((type) => type === '*') !== undefined;\n    }\n    isContentTypeAllowed(mimetype) {\n        if (this.allContentTypesAllowed()) {\n            return true;\n        }\n        return this.contentTypes.find((type) => type === mimetype) !== undefined;\n    }\n    isFileSizeAllowed(fileSize) {\n        if (!this.maxFileSize) {\n            return true;\n        }\n        return fileSize <= this.maxFileSize;\n    }\n    makeUploadFile(file, index) {\n        return {\n            fileIndex: index,\n            id: this.generateId(),\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            form: new FormData(),\n            progress: {\n                status: UploadStatus.Queue,\n                data: {\n                    percentage: 0,\n                    speed: 0,\n                    speedHuman: `${humanizeBytes(0)}/s`,\n                    startTime: null,\n                    endTime: null,\n                    eta: null,\n                    etaHuman: null\n                }\n            },\n            lastModifiedDate: new Date(file.lastModified),\n            sub: undefined,\n            nativeFile: file\n        };\n    }\n    parseResponseHeaders(httpHeaders) {\n        if (!httpHeaders) {\n            return;\n        }\n        return httpHeaders\n            .split('\\n')\n            .map((x) => x.split(/: */, 2))\n            .filter((x) => x[0])\n            .reduce((acc, x) => {\n            acc[x[0]] = x[1];\n            return acc;\n        }, {});\n    }\n}","originalLength":43504,"removedExports":[],"renderedExports":["humanizeBytes","NgUploaderService"],"renderedLength":12003},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ng-file-drop.directive.mjs":{"code":"class NgFileDropDirective {\n    elementRef;\n    options;\n    uploadInput;\n    uploadOutput;\n    upload;\n    el;\n    _sub;\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        this.uploadOutput = new EventEmitter();\n    }\n    ngOnInit() {\n        this._sub = [];\n        const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n        const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n        const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n        const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n        this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n        this.el = this.elementRef.nativeElement;\n        this._sub.push(this.upload.serviceEvents.subscribe((event) => {\n            this.uploadOutput.emit(event);\n        }));\n        if (this.uploadInput instanceof EventEmitter) {\n            this._sub.push(this.upload.initInputEvents(this.uploadInput));\n        }\n        this.el.addEventListener('drop', this.stopEvent, false);\n        this.el.addEventListener('dragenter', this.stopEvent, false);\n        this.el.addEventListener('dragover', this.stopEvent, false);\n    }\n    ngOnDestroy() {\n        if (this._sub) {\n            this._sub.forEach(sub => sub.unsubscribe());\n        }\n    }\n    stopEvent = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n    onDrop(e) {\n        e.stopPropagation();\n        e.preventDefault();\n        const event = { type: 'drop' };\n        this.uploadOutput.emit(event);\n        this.upload.handleFiles(e.dataTransfer.files);\n    }\n    onDragOver(e) {\n        if (!e) {\n            return;\n        }\n        const event = { type: 'dragOver' };\n        this.uploadOutput.emit(event);\n    }\n    onDragLeave(e) {\n        if (!e) {\n            return;\n        }\n        const event = { type: 'dragOut' };\n        this.uploadOutput.emit(event);\n    }\n    static ɵfac = function NgFileDropDirective_Factory(t) { return new (t || NgFileDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgFileDropDirective, selectors: [[\"\", \"ngFileDrop\", \"\"]], hostBindings: function NgFileDropDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"drop\", function NgFileDropDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); })(\"dragover\", function NgFileDropDirective_dragover_HostBindingHandler($event) { return ctx.onDragOver($event); })(\"dragleave\", function NgFileDropDirective_dragleave_HostBindingHandler($event) { return ctx.onDragLeave($event); });\n        } }, inputs: { options: \"options\", uploadInput: \"uploadInput\" }, outputs: { uploadOutput: \"uploadOutput\" } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileDropDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngFileDrop]'\n            }]\n    }], function () { return [{ type: i0.ElementRef }]; }, { options: [{\n            type: Input\n        }], uploadInput: [{\n            type: Input\n        }], uploadOutput: [{\n            type: Output\n        }], onDrop: [{\n            type: HostListener,\n            args: ['drop', ['$event']]\n        }], onDragOver: [{\n            type: HostListener,\n            args: ['dragover', ['$event']]\n        }], onDragLeave: [{\n            type: HostListener,\n            args: ['dragleave', ['$event']]\n        }] }); })();","originalLength":11351,"removedExports":[],"renderedExports":["NgFileDropDirective"],"renderedLength":3587},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ng-file-select.directive.mjs":{"code":"class NgFileSelectDirective {\n    elementRef;\n    options;\n    uploadInput;\n    uploadOutput;\n    upload;\n    el;\n    _sub;\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        this.uploadOutput = new EventEmitter();\n    }\n    ngOnInit() {\n        this._sub = [];\n        const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n        const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n        const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n        const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n        this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n        this.el = this.elementRef.nativeElement;\n        this.el.addEventListener('change', this.fileListener, false);\n        this._sub.push(this.upload.serviceEvents.subscribe((event) => {\n            this.uploadOutput.emit(event);\n        }));\n        if (this.uploadInput instanceof EventEmitter) {\n            this._sub.push(this.upload.initInputEvents(this.uploadInput));\n        }\n    }\n    ngOnDestroy() {\n        if (this.el) {\n            this.el.removeEventListener('change', this.fileListener, false);\n            this._sub.forEach(sub => sub.unsubscribe());\n        }\n    }\n    fileListener = () => {\n        if (this.el.files) {\n            this.upload.handleFiles(this.el.files);\n        }\n    };\n    static ɵfac = function NgFileSelectDirective_Factory(t) { return new (t || NgFileSelectDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgFileSelectDirective, selectors: [[\"\", \"ngFileSelect\", \"\"]], inputs: { options: \"options\", uploadInput: \"uploadInput\" }, outputs: { uploadOutput: \"uploadOutput\" } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileSelectDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngFileSelect]'\n            }]\n    }], function () { return [{ type: i0.ElementRef }]; }, { options: [{\n            type: Input\n        }], uploadInput: [{\n            type: Input\n        }], uploadOutput: [{\n            type: Output\n        }] }); })();","originalLength":7896,"removedExports":[],"renderedExports":["NgFileSelectDirective"],"renderedLength":2300},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/lib/ngx-uploader.module.mjs":{"code":"class NgxUploaderModule {\n    static ɵfac = function NgxUploaderModule_Factory(t) { return new (t || NgxUploaderModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgxUploaderModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxUploaderModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [NgFileDropDirective, NgFileSelectDirective],\n                exports: [NgFileDropDirective, NgFileSelectDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxUploaderModule, { declarations: [NgFileDropDirective, NgFileSelectDirective], exports: [NgFileDropDirective, NgFileSelectDirective] }); })();","originalLength":2357,"removedExports":[],"renderedExports":["NgxUploaderModule"],"renderedLength":837},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/public_api.mjs":{"code":"/*\n * Public API Surface of ngx-uploader\n */","originalLength":1048,"removedExports":[],"renderedExports":[],"renderedLength":44},"/Volumes/Storagino SSD/Develop/WebApps/third/ngx-uploader/dist/ngx-uploader/esm2022/ngx-uploader.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":504,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Directive, Input, Output, HostListener, NgModule } from '@angular/core';\nimport { Subject, Observable } from 'rxjs';\nimport { mergeMap, finalize } from 'rxjs/operators';\n\nvar UploadStatus;\n(function (UploadStatus) {\n    UploadStatus[UploadStatus[\"Queue\"] = 0] = \"Queue\";\n    UploadStatus[UploadStatus[\"Uploading\"] = 1] = \"Uploading\";\n    UploadStatus[UploadStatus[\"Done\"] = 2] = \"Done\";\n    UploadStatus[UploadStatus[\"Cancelled\"] = 3] = \"Cancelled\";\n})(UploadStatus || (UploadStatus = {}));\n\nfunction humanizeBytes(bytes) {\n    if (bytes === 0) {\n        return '0 Byte';\n    }\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nclass NgUploaderService {\n    queue;\n    serviceEvents;\n    uploadScheduler;\n    subs;\n    contentTypes;\n    maxUploads;\n    maxFileSize;\n    constructor(concurrency = Number.POSITIVE_INFINITY, contentTypes = ['*'], maxUploads = Number.POSITIVE_INFINITY, maxFileSize = Number.POSITIVE_INFINITY) {\n        this.queue = [];\n        this.serviceEvents = new EventEmitter();\n        this.uploadScheduler = new Subject();\n        this.subs = [];\n        this.contentTypes = contentTypes;\n        this.maxUploads = maxUploads;\n        this.maxFileSize = maxFileSize;\n        this.uploadScheduler\n            .pipe(mergeMap(upload => this.startUpload(upload), concurrency))\n            .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n    }\n    handleFiles(incomingFiles) {\n        const allowedIncomingFiles = [].reduce.call(incomingFiles, (acc, checkFile, i) => {\n            const futureQueueLength = acc.length + this.queue.length + 1;\n            if (this.isContentTypeAllowed(checkFile.type) &&\n                futureQueueLength <= this.maxUploads &&\n                this.isFileSizeAllowed(checkFile.size)) {\n                acc = acc.concat(checkFile);\n            }\n            else {\n                const rejectedFile = this.makeUploadFile(checkFile, i);\n                this.serviceEvents.emit({ type: 'rejected', file: rejectedFile });\n            }\n            return acc;\n        }, []);\n        this.queue.push(...[].map.call(allowedIncomingFiles, (file, i) => {\n            const uploadFile = this.makeUploadFile(file, i);\n            this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });\n            return uploadFile;\n        }));\n        this.serviceEvents.emit({ type: 'allAddedToQueue' });\n    }\n    initInputEvents(input) {\n        return input.subscribe((event) => {\n            switch (event.type) {\n                case 'uploadFile':\n                    const uploadFileIndex = this.queue.findIndex(file => file === event.file);\n                    if (uploadFileIndex !== -1 && event.file) {\n                        this.uploadScheduler.next({ file: this.queue[uploadFileIndex], event: event });\n                    }\n                    break;\n                case 'uploadAll':\n                    const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n                    files.forEach(file => this.uploadScheduler.next({ file: file, event: event }));\n                    break;\n                case 'cancel':\n                    const id = event.id || null;\n                    if (!id) {\n                        return;\n                    }\n                    const subs = this.subs.filter(sub => sub.id === id);\n                    subs.forEach(sub => {\n                        if (sub.sub) {\n                            sub.sub.unsubscribe();\n                            const fileIndex = this.queue.findIndex(file => file.id === id);\n                            if (fileIndex !== -1) {\n                                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n                                this.serviceEvents.emit({ type: 'cancelled', file: this.queue[fileIndex] });\n                            }\n                        }\n                    });\n                    break;\n                case 'cancelAll':\n                    this.subs.forEach(sub => {\n                        if (sub.sub) {\n                            sub.sub.unsubscribe();\n                        }\n                        const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n                        if (file) {\n                            file.progress.status = UploadStatus.Cancelled;\n                            this.serviceEvents.emit({ type: 'cancelled', file: file });\n                        }\n                    });\n                    break;\n                case 'remove':\n                    if (!event.id) {\n                        return;\n                    }\n                    const i = this.queue.findIndex(file => file.id === event.id);\n                    if (i !== -1) {\n                        const file = this.queue[i];\n                        this.queue.splice(i, 1);\n                        this.serviceEvents.emit({ type: 'removed', file: file });\n                    }\n                    break;\n                case 'removeAll':\n                    if (this.queue.length) {\n                        this.queue = [];\n                        this.serviceEvents.emit({ type: 'removedAll' });\n                    }\n                    break;\n            }\n        });\n    }\n    startUpload(upload) {\n        return new Observable(observer => {\n            const sub = this.uploadFile(upload.file, upload.event)\n                .pipe(finalize(() => {\n                if (!observer.closed) {\n                    observer.complete();\n                }\n            }))\n                .subscribe(output => {\n                observer.next(output);\n            }, err => {\n                observer.error(err);\n                observer.complete();\n            }, () => {\n                observer.complete();\n            });\n            this.subs.push({ id: upload.file.id, sub: sub });\n        });\n    }\n    uploadFile(file, event) {\n        return new Observable(observer => {\n            const url = event.url || '';\n            const method = event.method || 'POST';\n            const data = event.data || {};\n            const headers = event.headers || {};\n            const xhr = new XMLHttpRequest();\n            const time = new Date().getTime();\n            let progressStartTime = (file.progress.data && file.progress.data.startTime) || time;\n            let speed = 0;\n            let eta = null;\n            xhr.upload.addEventListener('progress', (e) => {\n                if (e.lengthComputable) {\n                    const percentage = Math.round((e.loaded * 100) / e.total);\n                    const diff = new Date().getTime() - time;\n                    speed = Math.round((e.loaded / diff) * 1000);\n                    progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\n                    eta = Math.ceil((e.total - e.loaded) / speed);\n                    file.progress = {\n                        status: UploadStatus.Uploading,\n                        data: {\n                            percentage: percentage,\n                            speed: speed,\n                            speedHuman: `${humanizeBytes(speed)}/s`,\n                            startTime: progressStartTime,\n                            endTime: null,\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta)\n                        }\n                    };\n                    observer.next({ type: 'uploading', file: file });\n                }\n            }, false);\n            xhr.upload.addEventListener('error', (e) => {\n                observer.error(e);\n                observer.complete();\n            });\n            xhr.onreadystatechange = () => {\n                if (xhr.readyState === XMLHttpRequest.DONE) {\n                    const speedAverage = Math.round((file.size / (new Date().getTime() - progressStartTime)) * 1000);\n                    file.progress = {\n                        status: UploadStatus.Done,\n                        data: {\n                            percentage: 100,\n                            speed: speedAverage,\n                            speedHuman: `${humanizeBytes(speedAverage)}/s`,\n                            startTime: progressStartTime,\n                            endTime: new Date().getTime(),\n                            eta: eta,\n                            etaHuman: this.secondsToHuman(eta || 0)\n                        }\n                    };\n                    file.responseStatus = xhr.status;\n                    try {\n                        file.response = JSON.parse(xhr.response);\n                    }\n                    catch (e) {\n                        file.response = xhr.response;\n                    }\n                    file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n                    observer.next({ type: 'done', file: file });\n                    observer.complete();\n                }\n            };\n            xhr.open(method, url, true);\n            xhr.withCredentials = event.withCredentials;\n            try {\n                const uploadFile = file.nativeFile;\n                const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n                if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n                    observer.complete();\n                }\n                Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n                let bodyToSend;\n                if (event.includeWebKitFormBoundary !== false) {\n                    Object.keys(data).forEach(key => file.form.append(key, data[key]));\n                    file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n                    bodyToSend = file.form;\n                }\n                else {\n                    bodyToSend = uploadFile;\n                }\n                this.serviceEvents.emit({ type: 'start', file: file });\n                xhr.send(bodyToSend);\n            }\n            catch (e) {\n                observer.complete();\n            }\n            return () => {\n                xhr.abort();\n            };\n        });\n    }\n    secondsToHuman(sec) {\n        return new Date(sec * 1000).toISOString().substr(11, 8);\n    }\n    generateId() {\n        return Math.random().toString(36).substring(7);\n    }\n    setContentTypes(contentTypes) {\n        if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\n            if (contentTypes.find((type) => type === '*') !== undefined) {\n                this.contentTypes = ['*'];\n            }\n            else {\n                this.contentTypes = contentTypes;\n            }\n            return;\n        }\n        this.contentTypes = ['*'];\n    }\n    allContentTypesAllowed() {\n        return this.contentTypes.find((type) => type === '*') !== undefined;\n    }\n    isContentTypeAllowed(mimetype) {\n        if (this.allContentTypesAllowed()) {\n            return true;\n        }\n        return this.contentTypes.find((type) => type === mimetype) !== undefined;\n    }\n    isFileSizeAllowed(fileSize) {\n        if (!this.maxFileSize) {\n            return true;\n        }\n        return fileSize <= this.maxFileSize;\n    }\n    makeUploadFile(file, index) {\n        return {\n            fileIndex: index,\n            id: this.generateId(),\n            name: file.name,\n            size: file.size,\n            type: file.type,\n            form: new FormData(),\n            progress: {\n                status: UploadStatus.Queue,\n                data: {\n                    percentage: 0,\n                    speed: 0,\n                    speedHuman: `${humanizeBytes(0)}/s`,\n                    startTime: null,\n                    endTime: null,\n                    eta: null,\n                    etaHuman: null\n                }\n            },\n            lastModifiedDate: new Date(file.lastModified),\n            sub: undefined,\n            nativeFile: file\n        };\n    }\n    parseResponseHeaders(httpHeaders) {\n        if (!httpHeaders) {\n            return;\n        }\n        return httpHeaders\n            .split('\\n')\n            .map((x) => x.split(/: */, 2))\n            .filter((x) => x[0])\n            .reduce((acc, x) => {\n            acc[x[0]] = x[1];\n            return acc;\n        }, {});\n    }\n}\n\nclass NgFileDropDirective {\n    elementRef;\n    options;\n    uploadInput;\n    uploadOutput;\n    upload;\n    el;\n    _sub;\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        this.uploadOutput = new EventEmitter();\n    }\n    ngOnInit() {\n        this._sub = [];\n        const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n        const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n        const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n        const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n        this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n        this.el = this.elementRef.nativeElement;\n        this._sub.push(this.upload.serviceEvents.subscribe((event) => {\n            this.uploadOutput.emit(event);\n        }));\n        if (this.uploadInput instanceof EventEmitter) {\n            this._sub.push(this.upload.initInputEvents(this.uploadInput));\n        }\n        this.el.addEventListener('drop', this.stopEvent, false);\n        this.el.addEventListener('dragenter', this.stopEvent, false);\n        this.el.addEventListener('dragover', this.stopEvent, false);\n    }\n    ngOnDestroy() {\n        if (this._sub) {\n            this._sub.forEach(sub => sub.unsubscribe());\n        }\n    }\n    stopEvent = (e) => {\n        e.stopPropagation();\n        e.preventDefault();\n    };\n    onDrop(e) {\n        e.stopPropagation();\n        e.preventDefault();\n        const event = { type: 'drop' };\n        this.uploadOutput.emit(event);\n        this.upload.handleFiles(e.dataTransfer.files);\n    }\n    onDragOver(e) {\n        if (!e) {\n            return;\n        }\n        const event = { type: 'dragOver' };\n        this.uploadOutput.emit(event);\n    }\n    onDragLeave(e) {\n        if (!e) {\n            return;\n        }\n        const event = { type: 'dragOut' };\n        this.uploadOutput.emit(event);\n    }\n    static ɵfac = function NgFileDropDirective_Factory(t) { return new (t || NgFileDropDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgFileDropDirective, selectors: [[\"\", \"ngFileDrop\", \"\"]], hostBindings: function NgFileDropDirective_HostBindings(rf, ctx) { if (rf & 1) {\n            i0.ɵɵlistener(\"drop\", function NgFileDropDirective_drop_HostBindingHandler($event) { return ctx.onDrop($event); })(\"dragover\", function NgFileDropDirective_dragover_HostBindingHandler($event) { return ctx.onDragOver($event); })(\"dragleave\", function NgFileDropDirective_dragleave_HostBindingHandler($event) { return ctx.onDragLeave($event); });\n        } }, inputs: { options: \"options\", uploadInput: \"uploadInput\" }, outputs: { uploadOutput: \"uploadOutput\" } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileDropDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngFileDrop]'\n            }]\n    }], function () { return [{ type: i0.ElementRef }]; }, { options: [{\n            type: Input\n        }], uploadInput: [{\n            type: Input\n        }], uploadOutput: [{\n            type: Output\n        }], onDrop: [{\n            type: HostListener,\n            args: ['drop', ['$event']]\n        }], onDragOver: [{\n            type: HostListener,\n            args: ['dragover', ['$event']]\n        }], onDragLeave: [{\n            type: HostListener,\n            args: ['dragleave', ['$event']]\n        }] }); })();\n\nclass NgFileSelectDirective {\n    elementRef;\n    options;\n    uploadInput;\n    uploadOutput;\n    upload;\n    el;\n    _sub;\n    constructor(elementRef) {\n        this.elementRef = elementRef;\n        this.uploadOutput = new EventEmitter();\n    }\n    ngOnInit() {\n        this._sub = [];\n        const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\n        const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\n        const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\n        const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\n        this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\n        this.el = this.elementRef.nativeElement;\n        this.el.addEventListener('change', this.fileListener, false);\n        this._sub.push(this.upload.serviceEvents.subscribe((event) => {\n            this.uploadOutput.emit(event);\n        }));\n        if (this.uploadInput instanceof EventEmitter) {\n            this._sub.push(this.upload.initInputEvents(this.uploadInput));\n        }\n    }\n    ngOnDestroy() {\n        if (this.el) {\n            this.el.removeEventListener('change', this.fileListener, false);\n            this._sub.forEach(sub => sub.unsubscribe());\n        }\n    }\n    fileListener = () => {\n        if (this.el.files) {\n            this.upload.handleFiles(this.el.files);\n        }\n    };\n    static ɵfac = function NgFileSelectDirective_Factory(t) { return new (t || NgFileSelectDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\n    static ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: NgFileSelectDirective, selectors: [[\"\", \"ngFileSelect\", \"\"]], inputs: { options: \"options\", uploadInput: \"uploadInput\" }, outputs: { uploadOutput: \"uploadOutput\" } });\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgFileSelectDirective, [{\n        type: Directive,\n        args: [{\n                selector: '[ngFileSelect]'\n            }]\n    }], function () { return [{ type: i0.ElementRef }]; }, { options: [{\n            type: Input\n        }], uploadInput: [{\n            type: Input\n        }], uploadOutput: [{\n            type: Output\n        }] }); })();\n\nclass NgxUploaderModule {\n    static ɵfac = function NgxUploaderModule_Factory(t) { return new (t || NgxUploaderModule)(); };\n    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgxUploaderModule });\n    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({});\n}\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgxUploaderModule, [{\n        type: NgModule,\n        args: [{\n                declarations: [NgFileDropDirective, NgFileSelectDirective],\n                exports: [NgFileDropDirective, NgFileSelectDirective]\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgxUploaderModule, { declarations: [NgFileDropDirective, NgFileSelectDirective], exports: [NgFileDropDirective, NgFileSelectDirective] }); })();\n\n/*\n * Public API Surface of ngx-uploader\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgFileDropDirective, NgFileSelectDirective, NgUploaderService, NgxUploaderModule, UploadStatus, humanizeBytes };\n//# sourceMappingURL=ngx-uploader.mjs.map\n","map":null},{"fileName":"ngx-uploader.mjs.map","needsCodeReference":false,"source":"{\"version\":3,\"file\":\"ngx-uploader.mjs\",\"sources\":[\"../../../projects/ngx-uploader/src/lib/interfaces.ts\",\"../../../projects/ngx-uploader/src/lib/ngx-uploader.class.ts\",\"../../../projects/ngx-uploader/src/lib/ng-file-drop.directive.ts\",\"../../../projects/ngx-uploader/src/lib/ng-file-select.directive.ts\",\"../../../projects/ngx-uploader/src/lib/ngx-uploader.module.ts\",\"../../../projects/ngx-uploader/src/public_api.ts\",\"../../../projects/ngx-uploader/src/ngx-uploader.ts\"],\"sourcesContent\":[\"import { Subscription } from 'rxjs';\\n\\nexport interface UploaderOptions {\\n  concurrency: number;\\n  allowedContentTypes?: string[];\\n  maxUploads?: number;\\n  maxFileSize?: number;\\n}\\n\\nexport interface BlobFile extends Blob {\\n  name: string;\\n}\\n\\nexport enum UploadStatus {\\n  Queue,\\n  Uploading,\\n  Done,\\n  Cancelled\\n}\\n\\nexport interface UploadProgress {\\n  status: UploadStatus;\\n  data?: {\\n    percentage: number;\\n    speed: number;\\n    speedHuman: string;\\n    startTime: number | null;\\n    endTime: number | null;\\n    eta: number | null;\\n    etaHuman: string | null;\\n  };\\n}\\n\\nexport interface UploadFile {\\n  id: string;\\n  fileIndex: number;\\n  lastModifiedDate: Date;\\n  name: string;\\n  size: number;\\n  type: string;\\n  form: FormData;\\n  progress: UploadProgress;\\n  response?: any;\\n  responseStatus?: number;\\n  sub?: Subscription | any;\\n  nativeFile?: File;\\n  responseHeaders?: { [key: string]: string };\\n}\\n\\nexport interface UploadOutput {\\n  type: 'addedToQueue' | 'allAddedToQueue' | 'uploading' | 'done' | 'start' | 'cancelled' | 'dragOver'\\n      | 'dragOut' | 'drop' | 'removed' | 'removedAll' | 'rejected';\\n  file?: UploadFile;\\n  nativeFile?: File;\\n}\\n\\nexport interface UploadInput {\\n  type: 'uploadAll' | 'uploadFile' | 'cancel' | 'cancelAll' | 'remove' | 'removeAll';\\n  url?: string;\\n  method?: string;\\n  id?: string;\\n  fieldName?: string;\\n  fileIndex?: number;\\n  file?: UploadFile;\\n  data?: { [key: string]: string | Blob };\\n  headers?: { [key: string]: string };\\n  includeWebKitFormBoundary?: boolean; // If false, only the file is send trough xhr.send (WebKitFormBoundary is omit)\\n  withCredentials?: boolean;\\n}\\n\",\"import { EventEmitter } from '@angular/core';\\nimport { Observable, Subject, Subscription } from 'rxjs';\\nimport { mergeMap, finalize } from 'rxjs/operators';\\nimport { UploadFile, UploadOutput, UploadInput, UploadStatus, BlobFile } from './interfaces';\\n\\nexport function humanizeBytes(bytes: number): string {\\n  if (bytes === 0) {\\n    return '0 Byte';\\n  }\\n\\n  const k = 1024;\\n  const sizes: string[] = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\\n  const i: number = Math.floor(Math.log(bytes) / Math.log(k));\\n\\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\\n}\\n\\nexport class NgUploaderService {\\n  queue: UploadFile[];\\n  serviceEvents: EventEmitter<UploadOutput>;\\n  uploadScheduler: Subject<{ file: UploadFile; event: UploadInput }>;\\n  subs: { id: string; sub: Subscription }[];\\n  contentTypes: string[];\\n  maxUploads: number;\\n  maxFileSize: number;\\n\\n  constructor(\\n    concurrency: number = Number.POSITIVE_INFINITY,\\n    contentTypes: string[] = ['*'],\\n    maxUploads: number = Number.POSITIVE_INFINITY,\\n    maxFileSize: number = Number.POSITIVE_INFINITY\\n  ) {\\n    this.queue = [];\\n    this.serviceEvents = new EventEmitter<UploadOutput>();\\n    this.uploadScheduler = new Subject();\\n    this.subs = [];\\n    this.contentTypes = contentTypes;\\n    this.maxUploads = maxUploads;\\n    this.maxFileSize = maxFileSize;\\n\\n    this.uploadScheduler\\n      .pipe(mergeMap(upload => this.startUpload(upload), concurrency))\\n      .subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\\n  }\\n\\n  handleFiles(incomingFiles: FileList): void {\\n    const allowedIncomingFiles: File[] = [].reduce.call(\\n      incomingFiles,\\n      (acc: File[], checkFile: File, i: number) => {\\n        const futureQueueLength = acc.length + this.queue.length + 1;\\n        if (\\n          this.isContentTypeAllowed(checkFile.type) &&\\n          futureQueueLength <= this.maxUploads &&\\n          this.isFileSizeAllowed(checkFile.size)\\n        ) {\\n          acc = acc.concat(checkFile);\\n        } else {\\n          const rejectedFile: UploadFile = this.makeUploadFile(checkFile, i);\\n          this.serviceEvents.emit({ type: 'rejected', file: rejectedFile });\\n        }\\n\\n        return acc;\\n      },\\n      []\\n    );\\n\\n    this.queue.push(\\n      ...[].map.call(allowedIncomingFiles, (file: File, i: number) => {\\n        const uploadFile: UploadFile = this.makeUploadFile(file, i);\\n        this.serviceEvents.emit({ type: 'addedToQueue', file: uploadFile });\\n        return uploadFile;\\n      })\\n    );\\n\\n    this.serviceEvents.emit({ type: 'allAddedToQueue' });\\n  }\\n\\n  initInputEvents(input: EventEmitter<UploadInput>): Subscription {\\n    return input.subscribe((event: UploadInput) => {\\n      switch (event.type) {\\n        case 'uploadFile':\\n          const uploadFileIndex = this.queue.findIndex(file => file === event.file);\\n          if (uploadFileIndex !== -1 && event.file) {\\n            this.uploadScheduler.next({ file: this.queue[uploadFileIndex], event: event });\\n          }\\n          break;\\n        case 'uploadAll':\\n          const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\\n          files.forEach(file => this.uploadScheduler.next({ file: file, event: event }));\\n          break;\\n        case 'cancel':\\n          const id = event.id || null;\\n          if (!id) {\\n            return;\\n          }\\n          const subs = this.subs.filter(sub => sub.id === id);\\n          subs.forEach(sub => {\\n            if (sub.sub) {\\n              sub.sub.unsubscribe();\\n              const fileIndex = this.queue.findIndex(file => file.id === id);\\n              if (fileIndex !== -1) {\\n                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\\n                this.serviceEvents.emit({ type: 'cancelled', file: this.queue[fileIndex] });\\n              }\\n            }\\n          });\\n          break;\\n        case 'cancelAll':\\n          this.subs.forEach(sub => {\\n            if (sub.sub) {\\n              sub.sub.unsubscribe();\\n            }\\n\\n            const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\\n            if (file) {\\n              file.progress.status = UploadStatus.Cancelled;\\n              this.serviceEvents.emit({ type: 'cancelled', file: file });\\n            }\\n          });\\n          break;\\n        case 'remove':\\n          if (!event.id) {\\n            return;\\n          }\\n\\n          const i = this.queue.findIndex(file => file.id === event.id);\\n          if (i !== -1) {\\n            const file = this.queue[i];\\n            this.queue.splice(i, 1);\\n            this.serviceEvents.emit({ type: 'removed', file: file });\\n          }\\n          break;\\n        case 'removeAll':\\n          if (this.queue.length) {\\n            this.queue = [];\\n            this.serviceEvents.emit({ type: 'removedAll' });\\n          }\\n          break;\\n      }\\n    });\\n  }\\n\\n  startUpload(upload: { file: UploadFile; event: UploadInput }): Observable<UploadOutput> {\\n    return new Observable(observer => {\\n      const sub = this.uploadFile(upload.file, upload.event)\\n        .pipe(\\n          finalize(() => {\\n            if (!observer.closed) {\\n              observer.complete();\\n            }\\n          })\\n        )\\n        .subscribe(\\n          output => {\\n            observer.next(output);\\n          },\\n          err => {\\n            observer.error(err);\\n            observer.complete();\\n          },\\n          () => {\\n            observer.complete();\\n          }\\n        );\\n\\n      this.subs.push({ id: upload.file.id, sub: sub });\\n    });\\n  }\\n\\n  uploadFile(file: UploadFile, event: UploadInput): Observable<UploadOutput> {\\n    return new Observable(observer => {\\n      const url = event.url || '';\\n      const method = event.method || 'POST';\\n      const data = event.data || {};\\n      const headers = event.headers || {};\\n\\n      const xhr = new XMLHttpRequest();\\n      const time: number = new Date().getTime();\\n      let progressStartTime: number = (file.progress.data && file.progress.data.startTime) || time;\\n      let speed = 0;\\n      let eta: number | null = null;\\n\\n      xhr.upload.addEventListener(\\n        'progress',\\n        (e: ProgressEvent) => {\\n          if (e.lengthComputable) {\\n            const percentage = Math.round((e.loaded * 100) / e.total);\\n            const diff = new Date().getTime() - time;\\n            speed = Math.round((e.loaded / diff) * 1000);\\n            progressStartTime = (file.progress.data && file.progress.data.startTime) || new Date().getTime();\\n            eta = Math.ceil((e.total - e.loaded) / speed);\\n\\n            file.progress = {\\n              status: UploadStatus.Uploading,\\n              data: {\\n                percentage: percentage,\\n                speed: speed,\\n                speedHuman: `${humanizeBytes(speed)}/s`,\\n                startTime: progressStartTime,\\n                endTime: null,\\n                eta: eta,\\n                etaHuman: this.secondsToHuman(eta)\\n              }\\n            };\\n\\n            observer.next({ type: 'uploading', file: file });\\n          }\\n        },\\n        false\\n      );\\n\\n      xhr.upload.addEventListener('error', (e: Event) => {\\n        observer.error(e);\\n        observer.complete();\\n      });\\n\\n      xhr.onreadystatechange = () => {\\n        if (xhr.readyState === XMLHttpRequest.DONE) {\\n          const speedAverage = Math.round((file.size / (new Date().getTime() - progressStartTime)) * 1000);\\n          file.progress = {\\n            status: UploadStatus.Done,\\n            data: {\\n              percentage: 100,\\n              speed: speedAverage,\\n              speedHuman: `${humanizeBytes(speedAverage)}/s`,\\n              startTime: progressStartTime,\\n              endTime: new Date().getTime(),\\n              eta: eta,\\n              etaHuman: this.secondsToHuman(eta || 0)\\n            }\\n          };\\n\\n          file.responseStatus = xhr.status;\\n\\n          try {\\n            file.response = JSON.parse(xhr.response);\\n          } catch (e) {\\n            file.response = xhr.response;\\n          }\\n\\n          file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\\n\\n          observer.next({ type: 'done', file: file });\\n\\n          observer.complete();\\n        }\\n      };\\n\\n      xhr.open(method, url, true);\\n      xhr.withCredentials = event.withCredentials;\\n\\n      try {\\n        const uploadFile = <BlobFile>file.nativeFile;\\n        const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\\n\\n        if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\\n          observer.complete();\\n        }\\n\\n        Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\\n\\n        let bodyToSend: FormData | BlobFile;\\n\\n        if (event.includeWebKitFormBoundary !== false) {\\n          Object.keys(data).forEach(key => file.form.append(key, data[key]));\\n          file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\\n          bodyToSend = file.form;\\n        } else {\\n          bodyToSend = uploadFile;\\n        }\\n\\n        this.serviceEvents.emit({ type: 'start', file: file });\\n        xhr.send(bodyToSend);\\n      } catch (e) {\\n        observer.complete();\\n      }\\n\\n      return () => {\\n        xhr.abort();\\n      };\\n    });\\n  }\\n\\n  secondsToHuman(sec: number): string {\\n    return new Date(sec * 1000).toISOString().substr(11, 8);\\n  }\\n\\n  generateId(): string {\\n    return Math.random().toString(36).substring(7);\\n  }\\n\\n  setContentTypes(contentTypes: string[]): void {\\n    if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\\n      if (contentTypes.find((type: string) => type === '*') !== undefined) {\\n        this.contentTypes = ['*'];\\n      } else {\\n        this.contentTypes = contentTypes;\\n      }\\n      return;\\n    }\\n    this.contentTypes = ['*'];\\n  }\\n\\n  allContentTypesAllowed(): boolean {\\n    return this.contentTypes.find((type: string) => type === '*') !== undefined;\\n  }\\n\\n  isContentTypeAllowed(mimetype: string): boolean {\\n    if (this.allContentTypesAllowed()) {\\n      return true;\\n    }\\n    return this.contentTypes.find((type: string) => type === mimetype) !== undefined;\\n  }\\n\\n  isFileSizeAllowed(fileSize: number): boolean {\\n    if (!this.maxFileSize) {\\n      return true;\\n    }\\n    return fileSize <= this.maxFileSize;\\n  }\\n\\n  makeUploadFile(file: File, index: number): UploadFile {\\n    return {\\n      fileIndex: index,\\n      id: this.generateId(),\\n      name: file.name,\\n      size: file.size,\\n      type: file.type,\\n      form: new FormData(),\\n      progress: {\\n        status: UploadStatus.Queue,\\n        data: {\\n          percentage: 0,\\n          speed: 0,\\n          speedHuman: `${humanizeBytes(0)}/s`,\\n          startTime: null,\\n          endTime: null,\\n          eta: null,\\n          etaHuman: null\\n        }\\n      },\\n      lastModifiedDate: new Date(file.lastModified),\\n      sub: undefined,\\n      nativeFile: file\\n    };\\n  }\\n\\n  private parseResponseHeaders(httpHeaders: string): { [key: string]: string } {\\n    if (!httpHeaders) {\\n      return;\\n    }\\n\\n    return httpHeaders\\n      .split('\\\\n')\\n      .map((x: string) => x.split(/: */, 2))\\n      .filter((x: string[]) => x[0])\\n      .reduce((acc: { [key: string]: string }, x: string[]) => {\\n        acc[x[0]] = x[1];\\n        return acc;\\n      }, {});\\n  }\\n}\\n\",\"import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy, HostListener } from '@angular/core';\\nimport { UploadOutput, UploadInput, UploaderOptions } from './interfaces';\\nimport { NgUploaderService } from './ngx-uploader.class';\\nimport { Subscription } from 'rxjs';\\n\\n@Directive({\\n  selector: '[ngFileDrop]'\\n})\\nexport class NgFileDropDirective implements OnInit, OnDestroy {\\n  @Input() options: UploaderOptions;\\n  @Input() uploadInput: EventEmitter<UploadInput>;\\n  @Output() uploadOutput: EventEmitter<UploadOutput>;\\n\\n  upload: NgUploaderService;\\n  el: HTMLInputElement;\\n\\n  _sub: Subscription[];\\n\\n  constructor(public elementRef: ElementRef) {\\n    this.uploadOutput = new EventEmitter<UploadOutput>();\\n  }\\n\\n  ngOnInit() {\\n    this._sub = [];\\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\\n\\n    this.el = this.elementRef.nativeElement;\\n\\n    this._sub.push(\\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\\n        this.uploadOutput.emit(event);\\n      })\\n    );\\n\\n    if (this.uploadInput instanceof EventEmitter) {\\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\\n    }\\n\\n    this.el.addEventListener('drop', this.stopEvent, false);\\n    this.el.addEventListener('dragenter', this.stopEvent, false);\\n    this.el.addEventListener('dragover', this.stopEvent, false);\\n  }\\n\\n  ngOnDestroy() {\\n      if (this._sub) {\\n        this._sub.forEach(sub => sub.unsubscribe());\\n      }\\n  }\\n\\n  stopEvent = (e: Event) => {\\n    e.stopPropagation();\\n    e.preventDefault();\\n  }\\n\\n  @HostListener('drop', ['$event'])\\n  public onDrop(e: any) {\\n    e.stopPropagation();\\n    e.preventDefault();\\n\\n    const event: UploadOutput = { type: 'drop' };\\n    this.uploadOutput.emit(event);\\n    this.upload.handleFiles(e.dataTransfer.files);\\n  }\\n\\n  @HostListener('dragover', ['$event'])\\n  public onDragOver(e: Event) {\\n    if (!e) {\\n      return;\\n    }\\n\\n    const event: UploadOutput = { type: 'dragOver' };\\n    this.uploadOutput.emit(event);\\n  }\\n\\n  @HostListener('dragleave', ['$event'])\\n  public onDragLeave(e: Event) {\\n    if (!e) {\\n      return;\\n    }\\n\\n    const event: UploadOutput = { type: 'dragOut' };\\n    this.uploadOutput.emit(event);\\n  }\\n}\\n\",\"import { Directive, ElementRef, EventEmitter, Input, Output, OnInit, OnDestroy } from '@angular/core';\\nimport { UploadOutput, UploaderOptions } from './interfaces';\\nimport { NgUploaderService } from './ngx-uploader.class';\\nimport { Subscription } from 'rxjs';\\n\\n@Directive({\\n  selector: '[ngFileSelect]'\\n})\\nexport class NgFileSelectDirective implements OnInit, OnDestroy {\\n  @Input() options: UploaderOptions;\\n  @Input() uploadInput: EventEmitter<any>;\\n  @Output() uploadOutput: EventEmitter<UploadOutput>;\\n\\n  upload: NgUploaderService;\\n  el: HTMLInputElement;\\n\\n  _sub: Subscription[];\\n\\n  constructor(public elementRef: ElementRef) {\\n    this.uploadOutput = new EventEmitter<UploadOutput>();\\n  }\\n\\n  ngOnInit() {\\n    this._sub = [];\\n    const concurrency = this.options && this.options.concurrency || Number.POSITIVE_INFINITY;\\n    const allowedContentTypes = this.options && this.options.allowedContentTypes || ['*'];\\n    const maxUploads = this.options && this.options.maxUploads || Number.POSITIVE_INFINITY;\\n    const maxFileSize = this.options && this.options.maxFileSize || Number.POSITIVE_INFINITY;\\n    this.upload = new NgUploaderService(concurrency, allowedContentTypes, maxUploads, maxFileSize);\\n\\n    this.el = this.elementRef.nativeElement;\\n    this.el.addEventListener('change', this.fileListener, false);\\n\\n    this._sub.push(\\n      this.upload.serviceEvents.subscribe((event: UploadOutput) => {\\n        this.uploadOutput.emit(event);\\n      })\\n    );\\n\\n    if (this.uploadInput instanceof EventEmitter) {\\n      this._sub.push(this.upload.initInputEvents(this.uploadInput));\\n    }\\n  }\\n\\n  ngOnDestroy() {\\n    if (this.el){\\n      this.el.removeEventListener('change', this.fileListener, false);\\n      this._sub.forEach(sub => sub.unsubscribe());\\n    }\\n  }\\n\\n  fileListener = () => {\\n    if (this.el.files) {\\n      this.upload.handleFiles(this.el.files);\\n    }\\n  }\\n}\\n\",\"import { NgModule } from '@angular/core';\\nimport { NgFileDropDirective } from './ng-file-drop.directive';\\nimport { NgFileSelectDirective } from './ng-file-select.directive';\\n\\n@NgModule({\\n  declarations: [NgFileDropDirective, NgFileSelectDirective],\\n  exports: [NgFileDropDirective, NgFileSelectDirective]\\n})\\nexport class NgxUploaderModule { }\\n\",\"/*\\n * Public API Surface of ngx-uploader\\n */\\n\\nexport * from './lib/interfaces';\\nexport * from './lib/ng-file-drop.directive';\\nexport * from './lib/ng-file-select.directive';\\nexport * from './lib/ngx-uploader.class';\\nexport * from './lib/ngx-uploader.module';\\n\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public_api';\\n\"],\"names\":[],\"mappings\":\"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\"}","type":"asset"}]}