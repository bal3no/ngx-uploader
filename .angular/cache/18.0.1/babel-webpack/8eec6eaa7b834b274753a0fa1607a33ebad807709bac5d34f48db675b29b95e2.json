{"ast":null,"code":"import { EventEmitter } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { mergeMap, finalize } from 'rxjs/operators';\nimport { UploadStatus } from './interfaces';\nexport function humanizeBytes(bytes) {\n  if (bytes === 0) {\n    return '0 Byte';\n  }\n  const k = 1024;\n  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB'];\n  const i = Math.floor(Math.log(bytes) / Math.log(k));\n  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n}\nexport class NgUploaderService {\n  queue;\n  serviceEvents;\n  uploadScheduler;\n  subs;\n  contentTypes;\n  maxUploads;\n  maxFileSize;\n  constructor(concurrency = Number.POSITIVE_INFINITY, contentTypes = ['*'], maxUploads = Number.POSITIVE_INFINITY, maxFileSize = Number.POSITIVE_INFINITY) {\n    this.queue = [];\n    this.serviceEvents = new EventEmitter();\n    this.uploadScheduler = new Subject();\n    this.subs = [];\n    this.contentTypes = contentTypes;\n    this.maxUploads = maxUploads;\n    this.maxFileSize = maxFileSize;\n    this.uploadScheduler.pipe(mergeMap(upload => this.startUpload(upload), concurrency)).subscribe(uploadOutput => this.serviceEvents.emit(uploadOutput));\n  }\n  handleFiles(incomingFiles) {\n    const allowedIncomingFiles = [].reduce.call(incomingFiles, (acc, checkFile, i) => {\n      const futureQueueLength = acc.length + this.queue.length + 1;\n      if (this.isContentTypeAllowed(checkFile.type) && futureQueueLength <= this.maxUploads && this.isFileSizeAllowed(checkFile.size)) {\n        acc = acc.concat(checkFile);\n      } else {\n        const rejectedFile = this.makeUploadFile(checkFile, i);\n        this.serviceEvents.emit({\n          type: 'rejected',\n          file: rejectedFile\n        });\n      }\n      return acc;\n    }, []);\n    this.queue.push(...[].map.call(allowedIncomingFiles, (file, i) => {\n      const uploadFile = this.makeUploadFile(file, i);\n      this.serviceEvents.emit({\n        type: 'addedToQueue',\n        file: uploadFile\n      });\n      return uploadFile;\n    }));\n    this.serviceEvents.emit({\n      type: 'allAddedToQueue'\n    });\n  }\n  initInputEvents(input) {\n    return input.subscribe(event => {\n      switch (event.type) {\n        case 'uploadFile':\n          const uploadFileIndex = this.queue.findIndex(file => file === event.file);\n          if (uploadFileIndex !== -1 && event.file) {\n            this.uploadScheduler.next({\n              file: this.queue[uploadFileIndex],\n              event: event\n            });\n          }\n          break;\n        case 'uploadAll':\n          const files = this.queue.filter(file => file.progress.status === UploadStatus.Queue);\n          files.forEach(file => this.uploadScheduler.next({\n            file: file,\n            event: event\n          }));\n          break;\n        case 'cancel':\n          const id = event.id || null;\n          if (!id) {\n            return;\n          }\n          const subs = this.subs.filter(sub => sub.id === id);\n          subs.forEach(sub => {\n            if (sub.sub) {\n              sub.sub.unsubscribe();\n              const fileIndex = this.queue.findIndex(file => file.id === id);\n              if (fileIndex !== -1) {\n                this.queue[fileIndex].progress.status = UploadStatus.Cancelled;\n                this.serviceEvents.emit({\n                  type: 'cancelled',\n                  file: this.queue[fileIndex]\n                });\n              }\n            }\n          });\n          break;\n        case 'cancelAll':\n          this.subs.forEach(sub => {\n            if (sub.sub) {\n              sub.sub.unsubscribe();\n            }\n            const file = this.queue.find(uploadFile => uploadFile.id === sub.id);\n            if (file) {\n              file.progress.status = UploadStatus.Cancelled;\n              this.serviceEvents.emit({\n                type: 'cancelled',\n                file: file\n              });\n            }\n          });\n          break;\n        case 'remove':\n          if (!event.id) {\n            return;\n          }\n          const i = this.queue.findIndex(file => file.id === event.id);\n          if (i !== -1) {\n            const file = this.queue[i];\n            this.queue.splice(i, 1);\n            this.serviceEvents.emit({\n              type: 'removed',\n              file: file\n            });\n          }\n          break;\n        case 'removeAll':\n          if (this.queue.length) {\n            this.queue = [];\n            this.serviceEvents.emit({\n              type: 'removedAll'\n            });\n          }\n          break;\n      }\n    });\n  }\n  startUpload(upload) {\n    return new Observable(observer => {\n      const sub = this.uploadFile(upload.file, upload.event).pipe(finalize(() => {\n        if (!observer.closed) {\n          observer.complete();\n        }\n      })).subscribe(output => {\n        observer.next(output);\n      }, err => {\n        observer.error(err);\n        observer.complete();\n      }, () => {\n        observer.complete();\n      });\n      this.subs.push({\n        id: upload.file.id,\n        sub: sub\n      });\n    });\n  }\n  uploadFile(file, event) {\n    return new Observable(observer => {\n      const url = event.url || '';\n      const method = event.method || 'POST';\n      const data = event.data || {};\n      const headers = event.headers || {};\n      const xhr = new XMLHttpRequest();\n      const time = new Date().getTime();\n      let progressStartTime = file.progress.data && file.progress.data.startTime || time;\n      let speed = 0;\n      let eta = null;\n      xhr.upload.addEventListener('progress', e => {\n        if (e.lengthComputable) {\n          const percentage = Math.round(e.loaded * 100 / e.total);\n          const diff = new Date().getTime() - time;\n          speed = Math.round(e.loaded / diff * 1000);\n          progressStartTime = file.progress.data && file.progress.data.startTime || new Date().getTime();\n          eta = Math.ceil((e.total - e.loaded) / speed);\n          file.progress = {\n            status: UploadStatus.Uploading,\n            data: {\n              percentage: percentage,\n              speed: speed,\n              speedHuman: `${humanizeBytes(speed)}/s`,\n              startTime: progressStartTime,\n              endTime: null,\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta)\n            }\n          };\n          observer.next({\n            type: 'uploading',\n            file: file\n          });\n        }\n      }, false);\n      xhr.upload.addEventListener('error', e => {\n        observer.error(e);\n        observer.complete();\n      });\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === XMLHttpRequest.DONE) {\n          const speedAverage = Math.round(file.size / (new Date().getTime() - progressStartTime) * 1000);\n          file.progress = {\n            status: UploadStatus.Done,\n            data: {\n              percentage: 100,\n              speed: speedAverage,\n              speedHuman: `${humanizeBytes(speedAverage)}/s`,\n              startTime: progressStartTime,\n              endTime: new Date().getTime(),\n              eta: eta,\n              etaHuman: this.secondsToHuman(eta || 0)\n            }\n          };\n          file.responseStatus = xhr.status;\n          try {\n            file.response = JSON.parse(xhr.response);\n          } catch (e) {\n            file.response = xhr.response;\n          }\n          file.responseHeaders = this.parseResponseHeaders(xhr.getAllResponseHeaders());\n          observer.next({\n            type: 'done',\n            file: file\n          });\n          observer.complete();\n        }\n      };\n      xhr.open(method, url, true);\n      xhr.withCredentials = event.withCredentials;\n      try {\n        const uploadFile = file.nativeFile;\n        const uploadIndex = this.queue.findIndex(outFile => outFile.nativeFile === uploadFile);\n        if (this.queue[uploadIndex].progress.status === UploadStatus.Cancelled) {\n          observer.complete();\n        }\n        Object.keys(headers).forEach(key => xhr.setRequestHeader(key, headers[key]));\n        let bodyToSend;\n        if (event.includeWebKitFormBoundary !== false) {\n          Object.keys(data).forEach(key => file.form.append(key, data[key]));\n          file.form.append(event.fieldName || 'file', uploadFile, uploadFile.name);\n          bodyToSend = file.form;\n        } else {\n          bodyToSend = uploadFile;\n        }\n        this.serviceEvents.emit({\n          type: 'start',\n          file: file\n        });\n        xhr.send(bodyToSend);\n      } catch (e) {\n        observer.complete();\n      }\n      return () => {\n        xhr.abort();\n      };\n    });\n  }\n  secondsToHuman(sec) {\n    return new Date(sec * 1000).toISOString().substr(11, 8);\n  }\n  generateId() {\n    return Math.random().toString(36).substring(7);\n  }\n  setContentTypes(contentTypes) {\n    if (typeof contentTypes !== 'undefined' && contentTypes instanceof Array) {\n      if (contentTypes.find(type => type === '*') !== undefined) {\n        this.contentTypes = ['*'];\n      } else {\n        this.contentTypes = contentTypes;\n      }\n      return;\n    }\n    this.contentTypes = ['*'];\n  }\n  allContentTypesAllowed() {\n    return this.contentTypes.find(type => type === '*') !== undefined;\n  }\n  isContentTypeAllowed(mimetype) {\n    if (this.allContentTypesAllowed()) {\n      return true;\n    }\n    return this.contentTypes.find(type => type === mimetype) !== undefined;\n  }\n  isFileSizeAllowed(fileSize) {\n    if (!this.maxFileSize) {\n      return true;\n    }\n    return fileSize <= this.maxFileSize;\n  }\n  makeUploadFile(file, index) {\n    return {\n      fileIndex: index,\n      id: this.generateId(),\n      name: file.name,\n      size: file.size,\n      type: file.type,\n      form: new FormData(),\n      progress: {\n        status: UploadStatus.Queue,\n        data: {\n          percentage: 0,\n          speed: 0,\n          speedHuman: `${humanizeBytes(0)}/s`,\n          startTime: null,\n          endTime: null,\n          eta: null,\n          etaHuman: null\n        }\n      },\n      lastModifiedDate: new Date(file.lastModified),\n      sub: undefined,\n      nativeFile: file\n    };\n  }\n  parseResponseHeaders(httpHeaders) {\n    if (!httpHeaders) {\n      return;\n    }\n    return httpHeaders.split('\\n').map(x => x.split(/: */, 2)).filter(x => x[0]).reduce((acc, x) => {\n      acc[x[0]] = x[1];\n      return acc;\n    }, {});\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}